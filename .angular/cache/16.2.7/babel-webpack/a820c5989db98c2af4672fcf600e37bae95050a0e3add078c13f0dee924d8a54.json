{"ast":null,"code":"import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  constructor(schedulerActionCtor = VirtualAction, maxFrames = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n    this.maxFrames = maxFrames;\n    this.frame = 0;\n    this.index = -1;\n  }\n  flush() {\n    const {\n      actions,\n      maxFrames\n    } = this;\n    let error;\n    let action;\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\nVirtualTimeScheduler.frameTimeFactor = 10;\nexport class VirtualAction extends AsyncAction {\n  constructor(scheduler, work, index = scheduler.index += 1) {\n    super(scheduler, work);\n    this.scheduler = scheduler;\n    this.work = work;\n    this.index = index;\n    this.active = true;\n    this.index = scheduler.index = index;\n  }\n  schedule(state, delay = 0) {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n  requestAsyncId(scheduler, id, delay = 0) {\n    this.delay = scheduler.frame + delay;\n    const {\n      actions\n    } = scheduler;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return 1;\n  }\n  recycleAsyncId(scheduler, id, delay = 0) {\n    return undefined;\n  }\n  _execute(state, delay) {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n  static sortActions(a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}","map":{"version":3,"names":["AsyncAction","Subscription","AsyncScheduler","VirtualTimeScheduler","constructor","schedulerActionCtor","VirtualAction","maxFrames","Infinity","frame","index","flush","actions","error","action","delay","shift","execute","state","unsubscribe","frameTimeFactor","scheduler","work","active","schedule","Number","isFinite","id","add","EMPTY","requestAsyncId","push","sort","sortActions","recycleAsyncId","undefined","_execute","a","b"],"sources":["/Users/fabriziovaccaro/Desktop/Fabri45555.github.io/node_modules/rxjs/dist/esm/internal/scheduler/VirtualTimeScheduler.js"],"sourcesContent":["import {AsyncAction} from './AsyncAction';\nimport {Subscription} from '../Subscription';\nimport {AsyncScheduler} from './AsyncScheduler';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  constructor(schedulerActionCtor = VirtualAction, maxFrames = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n    this.maxFrames = maxFrames;\n    this.frame = 0;\n    this.index = -1;\n  }\n\n  flush() {\n    const {actions, maxFrames} = this;\n    let error;\n    let action;\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nVirtualTimeScheduler.frameTimeFactor = 10;\n\nexport class VirtualAction extends AsyncAction {\n  constructor(scheduler, work, index = (scheduler.index += 1)) {\n    super(scheduler, work);\n    this.scheduler = scheduler;\n    this.work = work;\n    this.index = index;\n    this.active = true;\n    this.index = scheduler.index = index;\n  }\n\n  schedule(state, delay = 0) {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n\n  requestAsyncId(scheduler, id, delay = 0) {\n    this.delay = scheduler.frame + delay;\n    const {actions} = scheduler;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  recycleAsyncId(scheduler, id, delay = 0) {\n    return undefined;\n  }\n\n  _execute(state, delay) {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  static sortActions(a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}